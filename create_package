#!/usr/bin/python3

import json
from pathlib import Path
import subprocess
import sys
import tomllib
import zipfile


def create_package():
    """
    Create a .zip package for the addon.
    """
    current_dir = Path(__file__).parent.resolve()

    # Get the version from the manifest.toml
    with open(current_dir / "blender_manifest.toml", "rb") as f:
        manifest_data = tomllib.load(f)
        name = manifest_data["id"]
        version = manifest_data["version"]

    # Generate the file path
    name = f"{name}-{version}"
    zip_file = current_dir / "build" / f"{name}.zip"

    # Generate the blockset from .gitignore and static entries
    blockset = {
        ".git/",
        ".gitignore",
        ".vscode/",
        "create_package",
        "create_repository",
        "img/",
        "repository/",
        "poetry.lock",
        "pyproject.toml",
        "README.md",
    }
    with open(current_dir / ".gitignore") as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            blockset.add(line)

    # Pack the .zip file
    if zip_file.exists():
        print("Removing existing .zip file.")
        zip_file.unlink()
    zip_file.parent.mkdir(parents=True, exist_ok=True)

    # Create the zip file
    print(f"Creating .zip file {zip_file}")
    with zipfile.ZipFile(zip_file, "w", zipfile.ZIP_DEFLATED) as zf:
        for file_path in current_dir.rglob("*"):
            if file_path.is_file():
                # Get relative path from current_dir
                relative_path = file_path.relative_to(current_dir)

                # Check if file or any parent directory matches blockset
                path_parts = relative_path.parts
                should_skip = False

                for blocked in blockset:
                    blocked = blocked.rstrip("/")
                    # Check exact match or if file is under blocked directory
                    if (
                        str(relative_path) == blocked
                        or str(relative_path).startswith(blocked + "/")
                        or blocked in path_parts
                    ):
                        should_skip = True
                        break

                if not should_skip:
                    # Add file to zip with relative path
                    print(f"Adding {relative_path}")
                    zf.write(file_path, arcname=relative_path)


def create_repository(repo_url: str):
    """
    (Re-)create the repository for existing packages.
    """
    current_dir = Path(__file__).parent.resolve()
    repo_dir = current_dir / "repository"
    build_dir = current_dir / "build"

    # Resolve virtualenv symlink to find Blender binary
    python = Path(sys.executable).resolve()
    bl_exec = python.parents[3] / "blender"

    # Use virtualenv Blender if available
    if bl_exec.is_file():
        cmd = [bl_exec.as_posix()]

    # Fall back to path definition
    else:
        cmd = ["blender"]

    cmd += [
        "--command",
        "extension",
        "server-generate",
        f"--repo-dir={build_dir.as_posix()}",
    ]

    # Generate the repository
    subprocess.run(cmd, cwd=build_dir)

    # Edit the generated JSON
    build_json = build_dir / "index.json"
    with open(build_json, "r") as f:
        data = json.load(f)
        for package in data["data"]:
            name = Path(package["archive_url"]).name
            version = package["version"]
            package["archive_url"] = f"{repo_url}/releases/download/{version}/{name}"
    with open(build_json, "w") as f:
        json.dump(data, f, indent=2)

    # Move JSON into repo_dir
    build_json.rename(repo_dir / build_json.name)


if __name__ == "__main__":
    url = "https://github.com/Plyrolith/schalotte_tools"
    create_package()
    create_repository(url)
